---
title: "Veg Mod Exploration: stan"
author: "Tim Szewczyk"
date: "6/13/2017"
output: html_document
---

# Model naming scheme  
Each exploratory model file name begins with 'veg_SB' followed by a number representing the broad structure (currently, only sandbox 1 has really been developed). Then, models of successive complexity are numbered '_1', '_2', etc, representing:  

  + '_1': Y1, Y2_ds drawn from multivariate distributions about nu  
  + '_2': separate covariance matrices for Y1, Y2_ds (assumed)  
  + '_3': pr(WP|Evg) as data to split Y2_d (assumed) into Y2_ds  
  + '_4': X_d & B_d to model bias to generate Y2_d from Y2  
  + '_5': separate X_d & B_d for each covariate  
  + '_6': X_p & B_p to model pr(WP|Evg)  

Within these categories of structural complexity, some are appended further, representing:  

  + '-1': base model pretending distributions are normal  
  + '-2': constraints using data structures and native functions  
  + '-3': constraints using transformations  

```{r setEnv, echo=FALSE, message=FALSE}
library(sevcheck); library(magrittr); library(tidyverse); theme_set(theme_bw())
library(forcats); library(rstan); library(ggmcmc); library(mvtnorm)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

tr_gjam <- function(w, a=0.99) {
  eta <- w[-length(w)]
  eta[eta<0] <- 0
  w.p <- sum( (eta > 0 & eta < 1)*eta + (eta > 1) )
  
  if(w.p >= a) {
    while(sum(eta) > 1) {
      D.i <- (w.p^(-1)) * (1 - ((1-a)^(w.p/a)))
      eta <- D.i*eta
    }
  }
  c(eta, 1-sum(eta)) 
}



tr_lein <- function(Z.v, g=2) {
  Z.v[Z.v<0] <- 0
  Z.l <- length(Z.v) - 1
  if(Z.v[Z.l]==0) { Z.v[Z.l] <- 0.01 }
  c((Z.v[1:Z.l]^g), 1) / (1 + sum(Z.v[1:Z.l]^g))
}
```

# Read in data
```{r rdData}
# data from test grid (1-acre composition)
GRNT <- read.csv("data/t_y_mx.csv") %>% as.matrix
NLCD <- read.csv("data/t_x_mx.csv") %>% as.matrix
FIA <- runif(nrow(GRNT), 0, 1)

# Rearrange LC's
# t_mx order: [Dev, Evg, Hwd, Mxd, Other, WP]
GRNT <- GRNT[,c(1,5,3,6,2,4)]
colnames(GRNT) <- c("Dev", "Oth", "Hwd", "WP", "Evg", "Mxd")
NLCD <- NLCD[,c(1,5,3,2,4)]
colnames(NLCD) <- c("Dev", "Oth", "Hwd", "Evg", "Mxd")
```


# Simplest version
```{r veg_SB1_1}
# simulate data
## set parameters
nCell <- 1000
nLC <- 6
s2.grnt <- 0.001
s2.nlcd <- s2.grnt
cov.grnt <- cov(GRNT)/8
cov.nlcd <- cov(GRNT)/6
# cov.grnt <- diag(s2.grnt, nLC, nLC)
cell.samp <- sample(1:nrow(GRNT), nCell)

## generate data
nu <- GRNT[cell.samp,]
Y1 <- nu; Y2.ds <- nu
for(i in 1:nCell) {
  Y1[i,] <- rmvnorm(1, nu[i,], cov.grnt) %>% tr_gjam()
  Y2.ds[i,] <- rmvnorm(1, nu[i,], cov.nlcd) %>% tr_gjam()
}
plot(Y1, Y2.ds); plot(nu, Y1); plot(nu, Y2.ds)

Y1[Y1==0] <- 1e-17
Y2.ds[Y2.ds==0] <- 1e-17
d_SB1.2 <- list(N=nrow(nu), L=ncol(nu), Y1=Y1, Y2=Y2.ds, alpha=colMeans(nu))


# run models
out1 <- stan(file="mod_sandbox/veg_SB1_2-1.stan", data=d_SB1.2, thin=50)
out2 <- stan(file="mod_sandbox/veg_SB1_2-2.stan", data=d_SB1.2, thin=50)
# out3 <- stan(file="mod_sandbox/veg_SB1_2-3.stan", data=d_SB1.2, thin=50)

gg.nu <- ggs(out1, "nu") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu <- gg.nu %>% rename(value.1=value) %>%
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6),
         value.2 = ggs(out2, "nu") %>% 
           arrange(Parameter, Chain, Iteration) %>% .$value) %>% 
  group_by(Iteration, Chain, Cell) %>%
  mutate(value.1.eta=tr_gjam(value.1), value.1.scaled=value.1/sum(value.1),
         value.1.ZY=tr_lein(value.1), value.2.eta=tr_gjam(value.2),
         value.2.scaled=value.2/sum(value.2), value.2.ZY=tr_lein(value.2))
ggplot(gg.nu, aes(x=nu.true, y=value.1)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.02) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.1.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.02) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.2)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.02) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.2.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.02) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=value.1, y=value.2)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.02) + facet_wrap(~LC)

## RMSE
Y1.rmse <- ((nu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((nu - Y2.ds)^2) %>% colMeans %>% sqrt
gg.nu %>% group_by(LC) %>% mutate(sdev=(nu.true-value.1)^2) %>%
  summarise(mod.rmse=mean(sdev) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3), Y2.rmse=round(Y2.rmse,3),
         d.Y1=round(mod.rmse-Y1.rmse, 3),  pD.Y1=round(d.Y1/Y1.rmse,3),
         d.Y2=round(mod.rmse-Y2.rmse, 3),  pD.Y2=round(d.Y2/Y2.rmse,3)) %>%
  select(-c(d.Y1, d.Y2))
```





# Bias correction & pr(WP|Evg) -- NO TRANSFORMATIONS
```{r veg_SB1_6}
# simulate data
## global parameters
nCell <- 500
nLC <- 6

## simulation parameters
s2.grnt <- 0.001  # variance for grnt LCs
s2.nlcd <- 0.003  # variance for nlcd LCs

## latent LC proportions
nu <- GRNT[sample(1:nrow(GRNT), nCell),]

## covariance matrices
cov.grnt <- cov(GRNT)/10
cov.nlcd <- cov(GRNT)/10

## simulate bias in NLCD
### initialize objects
nB.d <- c(3, 3, 1, 1, 1)  # Dev, Oth, Hwd, Evg, Mxd
B.Cov <- c(1, 1, 0, 2, 0)  # which deltas to model
X.d <- vector("list", nLC-1)
B.d <- X.d
d <- matrix(nrow=nCell, ncol=nLC-1)
### generate betas & covariates, then calculate deltas
for(i in 1:(nLC-1)) {
  X.d[[i]] <- runif(nCell*(nB.d[i]), -1, 1) %>% matrix(nrow=nCell)*B.Cov[i]
  B.d[[i]] <- runif(nB.d[i], -0.5, 0.5) %>% matrix(nrow=nB.d[i])*B.Cov[i]
  d[,i] <- X.d[[i]] %*% B.d[[i]]
}

## proportion WP|Evg
nB.p <- 2
B.p <- c(1.2, 0.25)
p.nu <- nu[,4]/(nu[,4]+nu[,5]+0.0001)
p.nu[p.nu==0] <- 0.0001; p.nu[p.nu==1] <- 0.9999
X.p <- matrix(nrow=nCell, ncol=nB.p)
X.p[,1] <- logit(p.nu)/B.p[1] - B.p[2] + rnorm(nCell, 0, 0.5)
X.p[,2] <- 1
plot(antilogit(X.p %*% B.p), p.nu)

## generate Ys
### GRNT, NLCD.unbiased.split
Y1 <- nu; Y2.ds <- Y1
for(i in 1:nCell) {
  Y1[i,] <- rmvnorm(1, nu[i,], cov.grnt) %>% tr_gjam
  Y2.ds[i,] <- rmvnorm(1, nu[i,], cov.nlcd)
}
### NLCD: combine WP + Evg
Y2.d <- cbind(Y2.ds[,1:4], Y2.ds[,5] + Y2.ds[,6])
Y2.d <- cbind(Y2.ds[,1:3], Y2.ds[,4] + Y2.ds[,5], Y2.ds[,6])
### NLCD: add bias
Y2 <- (Y2.d - d) %>% apply(., 1, tr_gjam) %>% t
plot(cbind(Y1[,1:3], Y1[,4]+Y1[,5], Y1[,6]), Y2)
plot(nu, Y1) 
plot(cbind(nu[,1:3], nu[,4]+nu[,5], nu[,6]), Y2)

# run model
d_SB1 <- list(N=nrow(nu), L=ncol(nu), Y1=Y1, Y2=Y2, nB_d=nB.d, nB_p=nB.p,
                X_d1=X.d[[1]], X_d2=X.d[[2]], X_d3=X.d[[3]], 
                X_d4=X.d[[4]], X_d5=X.d[[5]], X_p=X.p)
out <- stan(file="mod_sandbox/veg_SB1_6-1.stan", data=d_SB1, thin=50, init=0)



# visualize
## nu
gg.nu <- ggs(out, "nu") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu$nu.true <- t(nu) %>% c %>% rep(each=nGG)
gg.nu$Y1 <- t(Y1) %>% c %>% rep(each=nGG)
gg.nu$LC <- 1:6 %>% rep(each=nGG) %>% rep(times=nCell)
gg.nu$Cell <- 1:nCell %>% rep(each=nGG*6)
gg.nu <- gg.nu %>% group_by(Iteration, Chain, Cell) %>%
  mutate(value.eta=tr_gjam(value), value.scaled=value/sum(value),
         value.ZY=tr_lein(value))
ggplot(gg.nu, aes(x=nu.true, y=value)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.ZY)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.scaled)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=value, y=value.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=Y1, y=value)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)

## nu medians
gg.med <- gg.nu %>% group_by(Cell, LC, Parameter) %>%
  summarise(med=median(value), nu.true=first(nu.true), Y1=first(Y1)) %>%
  ungroup() %>% group_by(Cell) %>%
  mutate(med.eta=tr_gjam(med), med.scaled=med/sum(med),
         med.ZY=tr_lein(med))
ggplot(gg.med, aes(x=nu.true, y=med)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC)
ggplot(gg.med, aes(x=nu.true, y=med.eta)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC)
ggplot(gg.med, aes(x=nu.true, y=Y1)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC)

## betas
gg.b <- ggs(out, "beta") %>% arrange(Parameter, Chain, Iteration)
gg.b$LC <- rep(c(1:5, NA), times=nGG*c(nB.d, nB.p)) 
gg.b$b.true <- c(unlist(B.d), B.p) %>% rep(each=nGG)
ggplot(gg.b, aes(x=b.true, y=value)) + geom_abline(slope=1, linetype=3) +
  geom_point(alpha=0.1)


## RMSE
nu2 <- cbind(nu[,1:3], NA, rowSums(nu[,4:5]), nu[,6])
Y1.rmse <- ((nu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((nu2 - cbind(Y2[,1:3], NA, Y2[,4:5]))^2) %>% colMeans %>% sqrt
gg.nu %>% group_by(LC) %>% mutate(sdev=(nu.true-value.eta)^2) %>%
  summarise(mod.rmse=mean(sdev) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3), Y2.rmse=c(round(Y2.rmse,3)),
         d.Y1=round(mod.rmse-Y1.rmse, 3),  pD.Y1=round(d.Y1/Y1.rmse,3),
         d.Y2=round(mod.rmse-Y2.rmse, 3),  pD.Y2=round(d.Y2/Y2.rmse,3)) %>%
  select(-c(d.Y1, d.Y2))
```








