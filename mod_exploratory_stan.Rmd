---
title: "Veg Mod Exploration: stan"
author: "Tim Szewczyk"
date: "6/13/2017"
output: html_document
---

# Model naming scheme  
Each exploratory model file name begins with 'veg_SB' followed by a number representing the broad structure (currently, only sandbox 1 has really been developed). Then, models of successive complexity are numbered '_1', '_2', etc, representing:  

  + '_1': Y1, Y2_ds drawn from multivariate distributions about nu  
  + '_2': separate covariance matrices for Y1, Y2_ds (assumed)  
  + '_3': pr(WP|Evg) as data to split Y2_d (assumed) into Y2_ds  
  + '_4': X_d & B_d to model bias to generate Y2_d from Y2  
  + '_5': separate X_d & B_d for each covariate  
  + '_6': X_p & B_p to model pr(WP|Evg)  

Within these categories of structural complexity, some are appended further, representing:  

  + '-1': base model pretending distributions are normal  
  + '-2': constraints using data structures and native functions  
  + '-3': constraints using transformations  

```{r setEnv, echo=FALSE, message=FALSE}
library(sevcheck); library(tidyverse); library(magrittr); theme_set(theme_bw())
library(forcats); library(rstan); library(ggmcmc); library(mvtnorm); library(msm)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

tr_gjam_inv <- function(w, a=0.99) {
  eta <- w[-length(w)]
  eta[eta<0] <- 0
  w.p <- sum( (eta > 0 & eta < 1)*eta + (eta > 1) )
  
  if(w.p >= a) {
    while(sum(eta) > 1) {
      D.i <- (w.p^(-1)) * (1 - ((1-a)^(w.p/a)))
      eta <- D.i*eta
    }
  }
  c(eta, 1-sum(eta)) 
}


tr_gjam <- function(eta, a=0.99) {
  w <- eta
  eta.p <- sum(eta[-length(eta)])
  if(eta.p > a) {
    C.i <- (eta.p^(-1)) * a * (log(1-eta.p)/log(1-a))
    w <- C.i*eta
  }
  w[w==0] <- rtnorm(sum(w==0), mean=0, sd=0.5, upper=0)
  w
}


tr_lein <- function(Z.v, g=2) {
  Z.v[Z.v<0] <- 0
  Z.l <- length(Z.v) - 1
  if(Z.v[Z.l]==0) { Z.v[Z.l] <- 0.01 }
  c((Z.v[1:Z.l]^g), 1) / (1 + sum(Z.v[1:Z.l]^g))
}
```

# Read in data
```{r rdData}
# data from test grid (1-acre composition)
GRNT <- read.csv("data/t_y_mx.csv") %>% as.matrix
NLCD <- read.csv("data/t_x_mx.csv") %>% as.matrix
FIA <- runif(nrow(GRNT), 0, 1)

# Rearrange LC's
# t_mx order: [Dev, Evg, Hwd, Mxd, Other, WP]
GRNT <- GRNT[,c(1,5,3,6,2,4)]
colnames(GRNT) <- c("Dev", "Oth", "Hwd", "WP", "Evg", "Mxd")
NLCD <- NLCD[,c(1,5,3,2,4)]
colnames(NLCD) <- c("Dev", "Oth", "Hwd", "Evg", "Mxd")
```


# Simplest version
```{r veg_SB1_1}
# simulate data
## set parameters
nCell <- 50
nLC <- 6
s2.grnt <- 0.001
s2.nlcd <- s2.grnt
cov.grnt <- cov(GRNT)/10
cov.nlcd <- cov(GRNT)/10
# cov.grnt <- diag(s2.grnt, nLC, nLC)
cell.samp <- sample(1:nrow(GRNT), nCell)

## generate data
nu <- GRNT[cell.samp,]
Y1 <- nu; Y2.ds <- nu
Y1.inv <- nu; Y2.inv <- nu
Y1.inv.inv <- nu; Y2.inv.inv <- nu
for(i in 1:nCell) {
  Y1[i,] <- rmvnorm(1, nu[i,], cov.grnt) %>% tr_gjam_inv() 
  Y2.ds[i,] <- rmvnorm(1, nu[i,], cov.nlcd) %>% tr_gjam_inv() 
}
plot(Y1, Y2.ds); plot(nu, Y1); plot(nu, Y2.ds)

# Y1[Y1==0] <- 1e-17
# Y2.ds[Y2.ds==0] <- 1e-17
d_SB1.2 <- list(N=nrow(nu), L=ncol(nu), Y1=Y1, Y2=Y2.ds, alpha=colMeans(nu))

inits <- colMeans(nu) %>% rep(nCell) %>% matrix(nrow=nCell, byrow=TRUE) %>%
  list(nu=.) %>% list %>% rep(4)

# run models
out1 <- stan(file="mod_sandbox/veg_SB1_2-1.stan", data=d_SB1.2, thin=50)
# out2 <- stan(file="mod_sandbox/veg_SB1_2-2.stan", data=d_SB1.2, thin=50)
out3 <- stan(file="mod_sandbox/veg_SB1_2-3.stan", data=d_SB1.2, thin=50)

gg.nu <- ggs(out1, "eta") %>% 
           droplevels() %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu <- gg.nu %>% rename(value.1=value) %>%
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6),
         value.2 = ggs(out3, "eta") %>% 
           droplevels() %>%
           arrange(Parameter, Chain, Iteration) %>% .$value) %>% 
  group_by(Iteration, Chain, Cell) %>%
  mutate(value.1.eta=tr_gjam_inv(value.1), value.1.ZY=tr_lein(value.1), 
         value.2.eta=tr_gjam_inv(value.2), value.2.ZY=tr_lein(value.2))
ggplot(gg.nu, aes(x=nu.true, y=value.1)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.1.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.2)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.2.eta)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=value.1, y=value.2)) + geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.05) + facet_wrap(~LC)

## RMSE
Y1.rmse <- ((nu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((nu - Y2.ds)^2) %>% colMeans %>% sqrt
gg.nu %>% group_by(LC) %>% 
  mutate(sdev.1=(nu.true-value.1)^2, sdev.2=(nu.true-value.2)^2) %>%
  summarise(mod.1.rmse=mean(sdev.1) %>% sqrt %>% round(3),
            mod.2.rmse=mean(sdev.2) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3), Y2.rmse=round(Y2.rmse,3),
         d.1.Y1=round(mod.1.rmse-Y1.rmse, 3),  pD.1.Y1=round(d.1.Y1/Y1.rmse,3),
         d.1.Y2=round(mod.1.rmse-Y2.rmse, 3),  pD.1.Y2=round(d.1.Y2/Y2.rmse,3),
         d.2.Y1=round(mod.2.rmse-Y1.rmse, 3),  pD.2.Y1=round(d.2.Y1/Y1.rmse,3),
         d.2.Y2=round(mod.2.rmse-Y2.rmse, 3),  pD.2.Y2=round(d.2.Y2/Y2.rmse,3)) %>%
  select(LC, pD.1.Y1, pD.1.Y2, pD.2.Y1, pD.2.Y2)
```





# Bias correction & pr(WP|Evg)
```{r veg_SB1_6}
time.df <- tibble(n=c(10, 500, 1000, 3000, 7500))
time.ls <- vector("list", length=4) 
names(time.ls) <- c("evg0_p0", "evg0_p1", "evg1_p0", "evg2_p2")
time.ls <- time.ls %>% list() %>% rep(nrow(time.df))
names(time.ls) <- time.df$n

# simulate data
for(r in 1:nrow(time.df)) {
  
sim.time <- system.time({
set.seed(4337)
## global parameters
nCell <- time.df$n[r]
nLC <- 6

## latent LC proportions
nu <- GRNT[sample(1:nrow(GRNT), nCell),]

## covariance matrices
cov.grnt <- cov(GRNT)
cov.nlcd <- cov(GRNT)

## simulate bias in NLCD
### initialize objects
nB.d <- c(2, 2, 1, 1, 1)  # Dev, Oth, Hwd, Evg, Mxd
B.Cov <- c(1, 1, 0, 1, 0)  # which deltas to model
X.d <- vector("list", nLC-1)
B.d <- X.d
d <- matrix(nrow=nCell, ncol=nLC-1)
### generate betas & covariates, then calculate deltas
for(i in 1:(nLC-1)) {
  X.d[[i]] <- runif(nCell*(nB.d[i]), -2, 2) %>% matrix(nrow=nCell)*B.Cov[i]
  B.d[[i]] <- runif(nB.d[i], -1, 1) %>% matrix(nrow=nB.d[i])*B.Cov[i]
  d[,i] <- X.d[[i]] %*% B.d[[i]]
}

## proportion WP|Evg
nB.p <- 2
B.p <- c(1.2, 0.25)
p.nu <- nu[,4]/(nu[,4]+nu[,5]+0.0001)
p.nu[p.nu==0] <- 0.0001; p.nu[p.nu==1] <- 0.9999
X.p <- matrix(nrow=nCell, ncol=nB.p)
X.p[,1] <- logit(p.nu)/B.p[1] - B.p[2] + rnorm(nCell, 0, 0.5)
X.p[,2] <- 1
plot(antilogit(X.p %*% B.p), p.nu)

## generate Ys
### GRNT, NLCD.unbiased.split
Y1 <- nu; Y2.ds <- Y1
for(i in 1:nCell) {
  Y1[i,] <- (rmvnorm(1, nu[i,], cov.grnt) + c(0,0,0,0,0,0.001)) %>% tr_gjam_inv
  Y2.ds[i,] <- rmvnorm(1, nu[i,], cov.nlcd)
}
### NLCD: combine WP + Evg
Y2.d <- cbind(Y2.ds[,1:3], Y2.ds[,4] + Y2.ds[,5], Y2.ds[,6])
### NLCD: add bias
Y2 <- ((Y2.d - d) + c(0,0,0,0,0.001)) %>% apply(., 1, tr_gjam_inv) %>% t
plot(cbind(Y1[,1:3], Y1[,4]+Y1[,5], Y1[,6]), Y2)
plot(nu, Y1) 
plot(cbind(nu[,1:3], nu[,4]+nu[,5], nu[,6]), Y2)
})
# run model
d_SB1 <- list(N=nrow(nu), L=ncol(nu), Y1=Y1[,-6], Y2=Y2[,-5], 
              nB_d=nB.d, nB_p=nB.p,
              X_d1=X.d[[1]], X_d2=X.d[[2]], X_d3=X.d[[3]], 
              X_d4=X.d[[4]], X_d5=X.d[[5]], X_p=X.p)


mod.time.1 <- system.time({
out <- stan(file="mod_sandbox/6-3_evg0_p0.stan",
            data=d_SB1, thin=50, init=0, chains=8, seed=4337)
})
gg.nu <- ggs(out, "n_eta") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu %<>% 
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         Y1 = t(Y1) %>% c %>% rep(each=nGG),
         Y2 = t(cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), Y2[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6)) %>% 
  write_csv(paste0("output/", names(time.ls[[1]])[1], 
                   "_", names(time.ls)[r], "cells.csv"))


mod.time.2 <- system.time({
out2 <- stan(file="mod_sandbox/6-3_evg0_p1.stan",
             data=d_SB1, thin=50, init=0, chains=8, seed=4337)
})
gg.nu2 <- ggs(out2, "n_eta") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu2, "nChains")*attr(gg.nu2, "nIterations")
gg.nu2 %<>% 
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         Y1 = t(Y1) %>% c %>% rep(each=nGG),
         Y2 = t(cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), Y2[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6)) %>% 
  write_csv(paste0("output/", names(time.ls[[1]])[2], 
                   "_", names(time.ls)[r], "cells.csv"))


mod.time.3 <- system.time({
out3 <- stan(file="mod_sandbox/6-3_evg1_p0.stan",
             data=d_SB1, thin=50, init=0, chains=8, seed=4337)
})
gg.nu3 <- ggs(out3, "n_eta") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu3, "nChains")*attr(gg.nu3, "nIterations")
gg.nu3 %<>% 
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         Y1 = t(Y1) %>% c %>% rep(each=nGG),
         Y2 = t(cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), Y2[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6)) %>% 
  write_csv(paste0("output/", names(time.ls[[1]])[3], 
                   "_", names(time.ls)[r], "cells.csv"))
mod.time.4 <- system.time({
out4 <- stan(file="mod_sandbox/6-3_evg2_p2.stan",
             data=d_SB1, thin=50, init=0, chains=8, seed=4337)
})
gg.nu4 <- ggs(out4, "n_eta") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu4, "nChains")*attr(gg.nu4, "nIterations")
gg.nu4 %<>% 
  mutate(nu.true = t(nu) %>% c %>% rep(each=nGG),
         Y1 = t(Y1) %>% c %>% rep(each=nGG),
         Y2 = t(cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), Y2[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6)) %>% 
  write_csv(paste0("output/", names(time.ls[[1]])[4], 
                   "_", names(time.ls)[r], "cells.csv"))
time.ls[[r]][[1]] <- get_elapsed_time(out)
time.ls[[r]][[2]] <- get_elapsed_time(out2)
time.ls[[r]][[3]] <- get_elapsed_time(out3)
time.ls[[r]][[4]] <- get_elapsed_time(out4)
cat("Finished row ", r, " with ", nCell, " cells:", 
    "\n\t", names(time.ls[[1]])[1], ": ", mod.time.1[3],
    "\n\t", names(time.ls[[1]])[2], ": ", mod.time.2[3],
    "\n\t", names(time.ls[[1]])[3], ": ", mod.time.3[3],
    "\n\t", names(time.ls[[1]])[4], ": ", mod.time.4[3],
    "\n", sep="")
}

time.ls %>% at_depth(2, as_tibble) %>% 
  at_depth(1, map_df, `[`, .id="model") %>% 
  map_df(`[`, .id="n") %>% 
  mutate(tot=(warmup + sample), perCell=tot/as.numeric(n)) %T>%
  write_csv("timing/cauch_Lmx.csv") %>%
  ggplot(aes(x=as.numeric(n), y=perCell, colour=model)) + 
  stat_smooth(method="loess", se=FALSE, span=2) + 
  geom_jitter(height=0, width=50) + scale_colour_brewer(type="qual", palette=2) + 
  labs(x="Number of cells", "Total time per cell (s/2000 iterations)")

time.ls %>% at_depth(2, as_tibble) %>% 
  at_depth(1, map_df, `[`, .id="model") %>% 
  map_df(`[`, .id="n") %>% 
  mutate(tot=(warmup + sample), perCell=tot/as.numeric(n)) %>%
  lm(perCell ~ model + as.numeric(n), data=.) %>% summary

# visualize
## nu
gg.nu %<>% rename(value.1=value)
gg.nu$value.2 <- gg.nu2$value
gg.nu$value.3 <- gg.nu3$value
gg.nu$value.4 <- gg.nu4$value
# gg.nu4 <- ggs(out4, "n_eta") %>% arrange(Parameter, Chain, Iteration)
# gg.nu$value.4 <- gg.nu2$value
# ggplot(gg.nu, aes(x=nu.true, y=value.1)) + geom_abline(slope=1, linetype=2) +
#   geom_point(alpha=0.05) + facet_wrap(~LC) + ylim(0,1)
# ggplot(gg.nu, aes(x=nu.true, y=value.2)) + geom_abline(slope=1, linetype=2) +
#   geom_point(alpha=0.05) + facet_wrap(~LC) + ylim(0,1)
# ggplot(gg.nu, aes(x=nu.true, y=value.3)) + geom_abline(slope=1, linetype=2) +
#   geom_point(alpha=0.05) + facet_wrap(~LC) + ylim(0,1) + xlim(0,1)
# ggplot(gg.nu, aes(x=nu.true, y=value.4)) + geom_abline(slope=1, linetype=2) +
#   geom_point(alpha=0.05) + facet_wrap(~LC) + ylim(0,1)

## nu medians
gg.med <- gg.nu %>% group_by(Cell, LC, Parameter) %>%
  summarise(med.1=median(value.1), med.2=median(value.2), 
            med.3=median(value.3), med.4=median(value.4),
            nu.true=first(nu.true), Y1=first(Y1), Y2=first(Y2)) %>%
  ungroup() %>% group_by(Cell)
ggplot(gg.med, aes(x=nu.true, y=med.1)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC) + ylim(0,1)
ggplot(gg.med, aes(x=nu.true, y=med.2)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC) + ylim(0,1)
ggplot(gg.med, aes(x=nu.true, y=med.3)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC) + ylim(0,1)
ggplot(gg.med, aes(x=nu.true, y=med.4)) +  geom_abline(slope=1, linetype=2) +
  geom_point(alpha=0.5) + facet_wrap(~LC) + ylim(0,1)

## betas
gg.b <- ggs(out, "beta") %>% arrange(Parameter, Chain, Iteration)
gg.b$LC <- rep(c(1:5, NA), times=nGG*c(nB.d*B.Cov, nB.p)) 
gg.b$b.true <- c(unlist(B.d[B.Cov==1]), B.p) %>% rep(each=nGG)
ggplot(gg.b, aes(x=b.true, y=value)) + geom_abline(slope=1, linetype=3) +
  geom_point(alpha=0.1)


## RMSE
Y1.rmse <- ((nu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((nu - cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), Y2[,5]))^2) %>% colMeans %>% sqrt
gg.nu %>% group_by(LC) %>% 
  mutate(sdev.1=(nu.true-value.1)^2, 
         sdev.2=(nu.true-value.2)^2,
         sdev.3=(nu.true-value.3)^2) %>%
  summarise(mod.1.rmse=mean(sdev.1) %>% sqrt %>% round(3),
            mod.2.rmse=mean(sdev.2) %>% sqrt %>% round(3),
            mod.3.rmse=mean(sdev.3) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3), Y2.rmse=round(Y2.rmse,3),
         d.1.Y1=round(mod.1.rmse-Y1.rmse, 3),  pD.1.Y1=round(d.1.Y1/Y1.rmse,3),
         d.1.Y2=round(mod.1.rmse-Y2.rmse, 3),  pD.1.Y2=round(d.1.Y2/Y2.rmse,3),
         d.2.Y1=round(mod.2.rmse-Y1.rmse, 3),  pD.2.Y1=round(d.2.Y1/Y1.rmse,3),
         d.2.Y2=round(mod.2.rmse-Y2.rmse, 3),  pD.2.Y2=round(d.2.Y2/Y2.rmse,3),
         d.3.Y1=round(mod.3.rmse-Y1.rmse, 3),  pD.3.Y1=round(d.3.Y1/Y1.rmse,3),
         d.3.Y2=round(mod.3.rmse-Y2.rmse, 3),  pD.3.Y2=round(d.3.Y2/Y2.rmse,3)) %>%
  select(LC, pD.1.Y1, pD.2.Y1, pD.3.Y1, pD.1.Y2, pD.2.Y2, pD.3.Y2)
```






```{r pred_test}
# data from test grid (1-acre composition)
grnt <- read.csv("data/out_02_2a_grnt.csv") %>% as.matrix
nlcd <- read.csv("data/out_02_2a_nlcd.csv") %>% as.matrix

nCell <- 500
nNew <- 500
nLC <- 6

## latent LC proportions
nu <- grnt[sample(1:nrow(grnt), nCell),]
nuNew <- grnt[sample(1:nrow(grnt), nNew),]

## covariance matrices
cov.grnt <- cov(grnt)/10
cov.nlcd <- cov(grnt)/10

## simulate bias in nlcd
### initialize objects
nB.d <- c(2, 2, 1, 1, 1)  # Dev, Oth, Hwd, Evg, Mxd
B.Cov <- c(1, 1, 0, 1, 0)  # which deltas to model
X.d <- vector("list", nLC-1)
X.dNew <- X.d
B.d <- X.d
d <- matrix(nrow=nCell, ncol=nLC-1)
dNew <- matrix(nrow=nNew, ncol=nLC-1)
### generate betas & covariates, then calculate deltas
for(i in 1:(nLC-1)) {
  X.d[[i]] <- runif(nCell*(nB.d[i]), -2, 2) %>% matrix(nrow=nCell)*B.Cov[i]
  X.dNew[[i]] <- runif(nNew*(nB.d[i]), -2, 2) %>% matrix(nrow=nNew)*B.Cov[i]
  B.d[[i]] <- runif(nB.d[i], -1, 1) %>% matrix(nrow=nB.d[i])*B.Cov[i]
  d[,i] <- X.d[[i]] %*% B.d[[i]]
  dNew[,i] <- X.dNew[[i]] %*% B.d[[i]]
}

## proportion WP|Evg
nB.p <- 2
B.p <- c(1.2, 0.25)
p.nu <- nu[,4]/(nu[,4]+nu[,5]+0.0001)
p.nu[p.nu==0] <- 0.0001; p.nu[p.nu==1] <- 0.9999
X.p <- matrix(nrow=nCell, ncol=nB.p)
X.p[,1] <- logit(p.nu)/B.p[1] - B.p[2] + rnorm(nCell, 0, 0.5)
X.p[,2] <- 1
p.nuNew <- nuNew[,4]/(nuNew[,4]+nuNew[,5]+0.0001)
p.nuNew[p.nuNew==0] <- 0.0001; p.nuNew[p.nuNew==1] <- 0.9999
X.pNew <- matrix(nrow=nNew, ncol=nB.p)
X.pNew[,1] <- logit(p.nuNew)/B.p[1] - B.p[2] + rnorm(nNew, 0, 0.5)
X.pNew[,2] <- 1


## generate Ys
### grnt, nlcd.unbiased.split
Y1 <- nu; Y2.ds <- Y1
for(i in 1:nCell) {
  Y1[i,] <- (rmvnorm(1, nu[i,], cov.grnt) + c(0,0,0,0,0,0.001)) %>% tr_gjam_inv
  Y2.ds[i,] <- rmvnorm(1, nu[i,], cov.nlcd)
}
Y2.dsNew <- nuNew
for (i in 1:nNew) {
  Y2.dsNew[i,] <- rmvnorm(1, nuNew[i,], cov.nlcd)
}
### nlcd: combine WP + Evg
Y2.d <- cbind(Y2.ds[,1:3], Y2.ds[,4] + Y2.ds[,5], Y2.ds[,6])
Y2.dNew <- cbind(Y2.dsNew[,1:3], Y2.dsNew[,4] + Y2.dsNew[,5], Y2.dsNew[,6])
### nlcd: add bias
Y2 <- ((Y2.d - d) + c(0,0,0,0,0.001)) %>% apply(., 1, tr_gjam_inv) %>% t
Y2New <- ((Y2.dNew - dNew) + c(0,0,0,0,0.001)) %>% apply(., 1, tr_gjam_inv) %>% t

d_SB1 <- list(N=nrow(nu), L=ncol(nu), Y1=Y1[,-6], Y2=Y2[,-5], 
              nB_d=nB.d, nB_p=nB.p,
              X_d1=X.d[[1]], X_d2=X.d[[2]], X_d3=X.d[[3]], 
              X_d4=X.d[[4]], X_d5=X.d[[5]], X_p=X.p,
              N_new=nNew, Y2_new=Y2New[,-5], 
              X_d1_new=X.dNew[[1]], X_d2_new=X.dNew[[2]], X_d3_new=X.dNew[[3]], 
              X_d4_new=X.dNew[[4]], X_d5_new=X.dNew[[5]], X_p_new=X.pNew)
out <- stan(file="mod_sandbox/6-3_newCells.stan", iter=2000,
            data=d_SB1, thin=50, init=0, chains=4, seed=4337)
gg.nu <- ggs(out, "n_eta") %>% 
  filter(!grepl("_new", .$Parameter)) %>%
  arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu %<>% rename(value.1=value) %>%
  mutate(nu = t(nu) %>% c %>% rep(each=nGG),
         Y2 = t(cbind(Y2[,1:3], Y2[,4]*antilogit(X.p %*% B.p),
                      Y2[,4]*(1-antilogit(X.p %*% B.p)), 
                      Y2[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nCell),
         Cell = 1:nCell %>% rep(each=nGG*6)) %>%
  group_by(Cell, LC, Parameter) %>%
  summarise(med=median(value.1), nu=first(nu), Y2=first(Y2)) %>%
  ungroup() %>% group_by(Cell)
gg.new <- ggs(out, "n_eta_new") %>% arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.new, "nChains")*attr(gg.new, "nIterations")
gg.new %<>% rename(value.1=value) %>%
  mutate(nuNew = t(nuNew) %>% c %>% rep(each=nGG),
         Y2New = t(cbind(Y2New[,1:3], Y2New[,4]*antilogit(X.pNew %*% B.p),
                      Y2New[,4]*(1-antilogit(X.pNew %*% B.p)),
                      Y2New[,5])) %>%
           c %>% rep(each=nGG),
         LC = 1:6 %>% rep(each=nGG) %>% rep(times=nNew),
         Cell = 1:nNew %>% rep(each=nGG*6)) %>%
  group_by(Cell, LC, Parameter) %>%
  summarise(medNew=median(value.1), nuNew=first(nuNew), Y2New=first(Y2New)) %>%
  ungroup() %>% group_by(Cell)

ggplot(gg.nu, aes(x=nu, y=med)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=Y2, y=med)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu, y=Y2)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)

ggplot(gg.new, aes(x=nuNew, y=medNew)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.new, aes(x=Y2New, y=medNew)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.new, aes(x=nuNew, y=Y2New)) + geom_point(alpha=0.2) + 
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC)

```

```{r block_test}
# data from test grid
grdSz <- "01_1a"
blockSize <- 10  # block = (blockSize x blockSize) grid cells

cb.i <- read_csv(paste0("data/roads_", grdSz, ".csv")) %>% 
  mutate(CellRow=1:n_distinct(top) %>% rep(n_distinct(left)),
         CellCol=1:n_distinct(left) %>% rep(each=n_distinct(top))) %>%
  filter((CellRow <= max((CellRow %/% blockSize) * blockSize)) &
           (CellCol <= max((CellCol %/% blockSize) * blockSize))) %>%
  mutate(BlockRow=((CellRow-1)%/%blockSize)+1, 
         BlockCol=((CellCol-1)%/%blockSize)+1,
         BlockID=paste(BlockCol, BlockRow, sep=".") %>% factor %>% as.numeric) %>%
  select(c(CellID, CellRow, CellCol, BlockID, BlockRow, BlockCol, left, top))

pop00 <- read_csv(paste0("data/pop00_", grdSz, ".csv")) %>% rename(CellID=category) %>% 
  mutate(BlockID=cb.i$BlockID[match(.$CellID, cb.i$CellID)]) %>%
  filter(!is.na(BlockID)) %>% group_by(BlockID) %>% summarise(popTot=sum(sum)) %>% 
  ungroup %>% mutate(popSc=scale(popTot))
rdLen <- read_csv(paste0("data/roads_", grdSz, ".csv")) %>% 
  mutate(BlockID=cb.i$BlockID[match(.$CellID, cb.i$CellID)]) %>%
  filter(!is.na(BlockID)) %>% group_by(BlockID) %>% summarise(rdLen=sum(roadLen)) %>% 
  ungroup %>% mutate(lenSc=scale(rdLen))
grnt <- read_csv(paste0("data/out_", grdSz, "_grnt.csv")) %>% 
  mutate(CellID=1:nrow(.)) %>% 
  mutate(BlockID=cb.i$BlockID[match(.$CellID, cb.i$CellID)]) %>%
  filter(!is.na(BlockID)) %>% group_by(BlockID) %>% 
  summarise(Dev=sum(V1)/n(), Oth=sum(V2)/n(), Hwd=sum(V3)/n(), 
            WP=sum(V4)/n(), Evg=sum(V5)/n(), Mxd=sum(V6)/n()) %>%
  select(-BlockID) %>% as.matrix
nlcd <- read_csv(paste0("data/out_",grdSz,"_nlcd.csv"))  %>% 
  mutate(CellID=1:nrow(.)) %>% 
  mutate(BlockID=cb.i$BlockID[match(.$CellID, cb.i$CellID)]) %>%
  filter(!is.na(BlockID)) %>% group_by(BlockID) %>% 
  summarise(Dev=sum(V1)/n(), Oth=sum(V2)/n(), Hwd=sum(V3)/n(), 
            Evg=sum(V4)/n(), Mxd=sum(V5)/n()) %>%
  select(-BlockID) %>% as.matrix



Ydiff <- cbind(grnt[,1:3]-nlcd[,1:3], 
               (grnt[,4]+grnt[,5])-nlcd[,4],
               grnt[,6]-nlcd[,5])
# Ydiff[Ydiff==0] <- NA

dev.df <- data.frame(Y1=grnt[,1], Y2=nlcd[,1], Yd=Ydiff[,1],
                 rLen=rdLen$lenSc, pop00=pop00$popSc)
pairs(dev.df, lower.panel=panel.smooth, upper.panel=panel.cor)
cor(dev.df, use="pairwise")

set.seed(2)
nCell <- 10
nNew <- 2
totCell <- nCell + nNew
allCell <- sample(1:nrow(grnt), totCell)
fitCell <- allCell[1:nCell]
newCell <- allCell[(nCell+1):length(allCell)]
nLC <- 6

# Y1 & Y2
Y1.fit <- grnt[fitCell,]
Y1.new <- grnt[newCell,]
Y2 <- nlcd[allCell,]

# covariates: bias (Dev, Oth, Hwd, Evg, Mxd)
## initialize
nBd <- c(2, 2, 1, 1, 1) 
BCov <- c(1, 1, 0, 1, 0)  # which deltas to model
Xd <- vector("list", nLC-1)
## fill
Xd[[1]] <- cbind(rdLen$lenSc[allCell], pop00$popSc[allCell])
for(i in 2:(nLC-1)) {
  Xd[[i]] <- runif(totCell*(nBd[i]), -2, 2) %>% matrix(nrow=totCell)*BCov[i]
}

# covariates: WP|Evg
## initialize
nBp <- 2
Bp <- c(1.2, 0.25)
p.fit <- Y1.fit[,4]/(Y1.fit[,4]+Y1.fit[,5]+0.0001)
p.new <- Y1.new[,4]/(Y1.new[,4]+Y1.new[,5]+0.0001)
p.all <- c(p.fit, p.new)
p.all[p.all==0] <- 0.0001; p.all[p.all==1] <- 0.9999
Xp <- matrix(nrow=totCell, ncol=nBp)
## fill
Xp[,1] <- logit(p.all)/Bp[1] - Bp[2] + rnorm(totCell, 0, 0.5)
Xp[,2] <- 1

# visualize data
plot(antilogit(Xp %*% Bp), p.all)
par(mfrow=c(2,3))
for(i in 1:3) {
  plot(c(Y1.fit[,i], Y1.new[,i]), Y2[,i], 
       main=paste("LC:",i), col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
  abline(b=1, a=0, lty=3)
} 
plot(c(Y1.fit[,4], Y1.new[,4]), Y2[,4]*(antilogit(Xp %*% Bp)), 
     main="LC: 4", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,5], Y1.new[,5]), Y2[,4]*(1-antilogit(Xp %*% Bp)), 
     main="LC: 5", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,6], Y1.new[,6]), Y2[,5], 
     main="LC: 6", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)



# load data
d_SB1 <- list(n1=nCell, n2=nCell+1, n3=totCell, L=6, 
              Y1=Y1.fit[,-6], Y2=Y2[,-5], 
              nB_d=nBd, nB_p=nBp,
              X_d1=Xd[[1]], X_d2=Xd[[2]], X_d3=Xd[[3]], 
              X_d4=Xd[[4]], X_d5=Xd[[5]], X_p=Xp)
out <- stan(file="mod_sandbox/6-3_newCells_Blocks.stan", iter=2000, 
            data=d_SB1, thin=50, init=0, chains=4, seed=4337)
gg.nu <- ggs(out, "n_eta") %>% 
  # filter(!grepl("_new", .$Parameter)) %>%
  arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu %<>% mutate(Y1=t(rbind(Y1.fit, Y1.new)) %>% c %>% rep(each=nGG),
                  Y2=t(cbind(Y2[,1:3], 
                             Y2[,4]*antilogit(Xp %*% Bp), 
                             Y2[,4]*(1-antilogit(Xp %*% Bp)), 
                             Y2[,5])) %>% c %>% rep(each=nGG),
                  LC=1:6 %>% rep(each=nGG) %>% rep(times=totCell),
                  Cell=1:totCell %>% rep(each=nGG*6),
                  Set=c("Y1 & Y2", "Y2") %>% rep(times=c(nCell, nNew)*nGG*6))

gg.med <- gg.nu %>% group_by(Cell, LC, Set, Parameter) %>%
  summarise(med=median(value), q05=quantile(value, 0.05), q25=quantile(value, 0.25),
            q75=quantile(value, 0.75), q95=quantile(value, 0.95),
            Y1=first(Y1), Y2=first(Y2)) %>%
  ungroup() %>% group_by(Cell)

ggplot(gg.med, aes(x=Y1, y=med, ymin=q25, ymax=q75)) + xlim(0,1) + ylim(0,1) + 
  geom_pointrange(alpha=0.5, colour="dodgerblue", fatten=1.5) + 
  geom_abline(slope=1, linetype=3) + facet_grid(Set~LC) 

ggplot(gg.med, aes(x=Y1, y=med)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_grid(Set~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.med, aes(x=Y1, y=Y2)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_grid(Set~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.med, aes(x=Y2, y=med)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_grid(Set~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.med) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=Y2-Y1)) + geom_density(aes(x=med-Y1), colour="blue")
ggplot(gg.med) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=(med-Y1)^2-(Y2-Y1)^2, colour=Set))

gg.med %>% ungroup %>% group_by(Set, LC) %>%
  summarise(rmse.mod=(med-Y1)^2 %>% mean %>% sqrt %>% round(3),
            rmse.Y2=(Y2-Y1)^2 %>% mean %>% sqrt %>% round(3),
            diff=rmse.mod-rmse.Y2)

ggplot(gg.med, aes(x=Y1, xend=Y1, y=Y2, yend=med, colour=abs(Y2-Y1)<abs(med-Y1))) + xlim(0,1) + ylim(0,1) +
    geom_abline(slope=1, linetype=3) + scale_colour_manual(values=c("darkgreen", "red")) +
    geom_segment(arrow=arrow(length=unit(0.1, "cm")), alpha=0.4) + facet_grid(Set~LC) +
    labs(x="Y1", y="Y2 -> median", main="no betas") + theme(legend.position="none")


gg.b <- ggs(out, "beta")
ggs_caterpillar(gg.b) + geom_vline(xintercept=0)
```


```{r realData_test}
# data from test grid
grdSz <- "04_1k"
grnt <- read.csv(paste0("data/out_",grdSz,"_grnt.csv")) %>% as.matrix
nlcd <- read.csv(paste0("data/out_",grdSz,"_nlcd.csv")) %>% as.matrix
rdLen <- read_csv(paste0("data/roads_",grdSz,".csv")) %>% 
  mutate(lenSc=scale(log(roadLen+1)), lCt=log(roadCt+1)) %>% arrange(CellID)
rdDist <- read_csv(paste0("data/rdDist_",grdSz,".csv")) %>% 
  mutate(disSc=scale(log(distance+1))) %>% arrange(CellID)
pop00 <- read_csv(paste0("data/pop00_",grdSz,".csv")) %>% 
  mutate(popSc=scale(log(sum+1))) %>% rename(CellID=category) %>% arrange(CellID)
pop90 <- read_csv(paste0("data/pop90_",grdSz,".csv")) %>% 
  mutate(popSc=scale(log(sum+1))) %>% rename(CellID=category) %>% arrange(CellID)
house90 <- read_csv(paste0("data/housing90_",grdSz,".csv")) %>% 
  mutate(hdSc=scale(log(sum+1))) %>% rename(CellID=category) %>% arrange(CellID)


Ydiff <- cbind(grnt[,1:3]-nlcd[,1:3], 
               (grnt[,4]+grnt[,5])-nlcd[,4],
               grnt[,6]-nlcd[,5])
# Ydiff[Ydiff==0] <- NA

dev.df <- data.frame(Y1=grnt[,1], Y2=nlcd[,1], Yd=Ydiff[,1],
                 rLen=rdLen$lenSc, rCt=rdLen$lCt, rDist=rdDist$disSc,
                 pop00=pop00$popSc)
dev.df$pop90 <- pop90$popSc[match(rdLen$CellID, pop90$CellID)]
dev.df$hd90 <- house90$hdSc[match(rdLen$CellID, house90$CellID)]
pairs(dev.df, lower.panel=panel.smooth, upper.panel=panel.cor)
cor(dev.df, use="pairwise")

nCell <- 12
nNew <- 8
totCell <- nCell + nNew
allCell <- sample(1:nrow(grnt), totCell)
fitCell <- allCell[1:nCell]
newCell <- allCell[(nCell+1):length(allCell)]
nLC <- 6

# Y1 & Y2
Y1.fit <- grnt[fitCell,]
Y1.new <- grnt[newCell,]
Y2 <- nlcd[allCell,]

# covariates: bias (Dev, Oth, Hwd, Evg, Mxd)
## initialize
nBd <- c(2, 2, 1, 1, 1) 
BCov <- c(1, 1, 0, 1, 0)  # which deltas to model
Xd <- vector("list", nLC-1)
## fill
Xd[[1]] <- cbind(rdLen$lenSc[allCell], pop00$popSc[allCell])
for(i in 2:(nLC-1)) {
  Xd[[i]] <- runif(totCell*(nBd[i]), -2, 2) %>% matrix(nrow=totCell)*BCov[i]
}

# covariates: WP|Evg
## initialize
nBp <- 2
Bp <- c(1.2, 0.25)
p.fit <- Y1.fit[,4]/(Y1.fit[,4]+Y1.fit[,5]+0.0001)
p.new <- Y1.new[,4]/(Y1.new[,4]+Y1.new[,5]+0.0001)
p.all <- c(p.fit, p.new)
p.all[p.all==0] <- 0.0001; p.all[p.all==1] <- 0.9999
Xp <- matrix(nrow=totCell, ncol=nBp)
## fill
Xp[,1] <- logit(p.all)/Bp[1] - Bp[2] + rnorm(totCell, 0, 0.5)
Xp[,2] <- 1

# visualize data
plot(antilogit(Xp %*% Bp), p.all)
par(mfrow=c(2,3))
for(i in 1:3) {
  plot(c(Y1.fit[,i], Y1.new[,i]), Y2[,i], 
       main=paste("LC:",i), col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
  abline(b=1, a=0, lty=3)
} 
plot(c(Y1.fit[,4], Y1.new[,4]), Y2[,4]*(antilogit(Xp %*% Bp)), 
     main="LC: 4", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,5], Y1.new[,5]), Y2[,4]*(1-antilogit(Xp %*% Bp)), 
     main="LC: 5", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,6], Y1.new[,6]), Y2[,5], 
     main="LC: 6", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)



# load data
d_SB1 <- list(N_Y1=nCell, N_Y2=totCell, L=6, 
              Y1=Y1.fit[,-6], Y2=Y2[,-5], 
              nB_d=nBd, nB_p=nBp,
              X_d1=Xd[[1]], X_d2=Xd[[2]], X_d3=Xd[[3]], 
              X_d4=Xd[[4]], X_d5=Xd[[5]], X_p=Xp)
out <- stan(file="mod_sandbox/6-3_newCells_InMod.stan", iter=4000, 
            data=d_SB1, thin=50, init=0, chains=8, seed=4337)
gg.nu <- ggs(out, "n_eta") %>% 
  # filter(!grepl("_new", .$Parameter)) %>%
  arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu %<>% mutate(Y1=t(rbind(Y1.fit, Y1.new)) %>% c %>% rep(each=nGG),
                  Y2=t(cbind(Y2[,1:3], 
                             Y2[,4]*antilogit(Xp %*% Bp), 
                             Y2[,4]*(1-antilogit(Xp %*% Bp)), 
                             Y2[,5])) %>% c %>% rep(each=nGG),
                  LC=1:6 %>% rep(each=nGG) %>% rep(times=totCell),
                  Cell=1:totCell %>% rep(each=nGG*6),
                  Set=c("GRANIT & NLCD", "NLCD") %>% rep(times=c(nCell, nNew)*nGG*6)) %>%
  group_by(Cell, LC, Set, Parameter) %>%
  summarise(med=median(value), Y1=first(Y1), Y2=first(Y2)) %>%
  ungroup() %>% group_by(Cell)
# gg.new <- ggs(out, "n_eta_new") %>% arrange(Parameter, Chain, Iteration)
# nGG <- attr(gg.new, "nChains")*attr(gg.new, "nIterations")
# gg.new %<>% mutate(Y1.new=t(Y1.new) %>% c %>% rep(each=nGG),
#                   Y2.new=t(cbind(Y2.new[,1:3], 
#                                  Y2.new[,4]*antilogit(Xp.new %*% Bp),
#                                  Y2.new[,4]*(1-antilogit(Xp.new %*% Bp)), 
#                                  Y2.new[,5])) %>% c %>% rep(each=nGG),
#                   LC=1:6 %>% rep(each=nGG) %>% rep(times=nCell),
#                   Cell=1:nCell %>% rep(each=nGG*6)) %>%
#   group_by(Cell, LC, Parameter) %>%
#   summarise(med=median(value), Y1.new=first(Y1.new), Y2.new=first(Y2.new)) %>%
#   ungroup() %>% group_by(Cell)

ggplot(gg.nu, aes(x=Y1, y=med, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu, aes(x=Y1, y=Y2, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu, aes(x=Y2, y=med, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=Y2-Y1)) + geom_density(aes(x=med-Y1), colour="blue")
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=(med-Y1)^2-(Y2-Y1)^2, colour=Set))

gg.b <- ggs(out, "beta")
ggs_caterpillar(gg.b) + geom_vline(xintercept=0)

gg.nu %>% ungroup %>% group_by(Set, LC) %>%
  summarise(rmse.mod=(med-Y1)^2 %>% mean %>% sqrt %>% round(3),
            rmse.Y2=(Y2-Y1)^2 %>% mean %>% sqrt %>% round(3),
            diff=rmse.mod-rmse.Y2)

ggplot(gg.nu, aes(x=Y1, xend=Y1, y=Y2, yend=med, colour=abs(Y2-Y1)<abs(med-Y1))) + xlim(0,1) + ylim(0,1) +
    geom_abline(slope=1, linetype=3) + scale_colour_manual(values=c("darkgreen", "red")) +
    geom_segment(arrow=arrow(length=unit(0.1, "cm")), alpha=0.2) + facet_grid(Set~LC) +
    labs(x="Y1", y="Y2 -> median", main="no betas") + theme(legend.position="none")


```

```{r predictionsSimData}
# data from test grid
grdSz <- "01_1a"
grnt <- read.csv(paste0("data/out_",grdSz,"_grnt.csv")) %>% as.matrix
nlcd <- read.csv(paste0("data/out_",grdSz,"_nlcd.csv")) %>% as.matrix
rdLen <- read_csv(paste0("data/roads_",grdSz,".csv")) %>% 
  mutate(lenSc=scale(log(roadLen+1)), lCt=log(roadCt+1)) %>% arrange(CellID)
rdDist <- read_csv(paste0("data/rdDist_",grdSz,".csv")) %>% 
  mutate(disSc=scale(log(distance+1))) %>% arrange(CellID)
pop00 <- read_csv(paste0("data/pop00_",grdSz,".csv")) %>% 
  mutate(popSc=scale(log(sum+1))) %>% rename(CellID=category) %>% arrange(CellID)

Ydiff <- cbind(grnt[,1:3]-nlcd[,1:3], 
               (grnt[,4]+grnt[,5])-nlcd[,4],
               grnt[,6]-nlcd[,5])
Ydiff[Ydiff==0] <- NA

plot(rdLen$lenSc, Ydiff[,1], col=rgb(0,0,0,0.1))
  lines(lowess(rdLen$lenSc, Ydiff[,1]), col="blue")
plot(rdLen$lCt, Ydiff[,1], col=rgb(0,0,0,0.1))
  lines(lowess(rdLen$lCt, Ydiff[,1]), col="blue")
plot(rdDist$disSc, Ydiff[,1], col=rgb(0,0,0,0.1))
  lines(lowess(rdDist$disSc, Ydiff[,1]), col="blue")
plot(pop00$popSc, Ydiff[,1], col=rgb(0,0,0,0.1))
  lines(lowess(pop00$popSc, Ydiff[,1]), col="blue")

nCell <- 60
nNew <- 40
totCell <- nCell + nNew
allCell <- sample(1:nrow(grnt), totCell)
fitCell <- allCell[1:nCell]
newCell <- allCell[(nCell+1):length(allCell)]
nLC <- 6

# Y1 & Y2
Y1.fit <- grnt[fitCell,]
Y1.new <- grnt[newCell,]
Y2 <- nlcd[allCell,]

# covariates: bias (Dev, Oth, Hwd, Evg, Mxd)
## initialize
nBd <- c(2, 2, 1, 1, 1) 
BCov <- c(1, 1, 0, 1, 0)  # which deltas to model
Xd <- vector("list", nLC-1)
Bd <- Xd
## fill
Xd[[1]] <- cbind(rdLen$lenSc[allCell], rdDist$disSc[allCell])
for(i in 1:(nLC-1)) {
  Xd[[i]] <- runif(totCell*(nBd[i]), -2, 2) %>% matrix(nrow=totCell)*BCov[i]
  Bd[[i]] <- runif(nBd[i], -1, 1) %>% matrix(nrow=nBd[i])*BCov[i]
}
Y2[,1] <- c(Y1.fit[,1], Y1.new[,1]) + Xd[[1]] %*% Bd[[1]]
Y2[,2] <- c(Y1.fit[,2], Y1.new[,2]) + Xd[[2]] %*% Bd[[2]]
Y2[,3] <- c(Y1.fit[,3], Y1.new[,3]) + Xd[[3]] %*% Bd[[3]]
Y2[,4] <- c(Y1.fit[,4], Y1.new[,4]) + c(Y1.fit[,5], Y1.new[,5]) + Xd[[4]] %*% Bd[[4]]
Y2[,5] <- 1 - rowSums(Y2[,1:4])
Y2 <- Y2 %>% apply(., 1, tr_gjam_inv) %>% t
Y2[Y2<0] <- 0; Y2[Y2>1] <- 1

# covariates: WP|Evg
## initialize
nBp <- 2
Bp <- c(1.2, 0.25)
p.fit <- Y1.fit[,4]/(Y1.fit[,4]+Y1.fit[,5]+0.0001)
p.new <- Y1.new[,4]/(Y1.new[,4]+Y1.new[,5]+0.0001)
p.all <- c(p.fit, p.new)
p.all[p.all==0] <- 0.0001; p.all[p.all==1] <- 0.9999
Xp <- matrix(nrow=totCell, ncol=nBp)
## fill
Xp[,1] <- logit(p.all)/Bp[1] - Bp[2] + rnorm(totCell, 0, 0.5)
Xp[,2] <- 1

# visualize data
plot(antilogit(Xp %*% Bp), p.all)
par(mfrow=c(2,3))
for(i in 1:3) {
  plot(c(Y1.fit[,i], Y1.new[,i]), Y2[,i], 
       main=paste("LC:",i), col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
  abline(b=1, a=0, lty=3)
} 
plot(c(Y1.fit[,4], Y1.new[,4]), Y2[,4]*(antilogit(Xp %*% Bp)), 
     main="LC: 4", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,5], Y1.new[,5]), Y2[,4]*(1-antilogit(Xp %*% Bp)), 
     main="LC: 5", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)
plot(c(Y1.fit[,6], Y1.new[,6]), Y2[,5], 
     main="LC: 6", col=rgb(0,0,0,0.5), ylim=c(0,1), xlim=c(0,1))
abline(b=1, a=0, lty=3)



# load data
d_SB1 <- list(N_Y1=nCell, N_Y2=totCell, L=6, 
              Y1=Y1.fit[,-6], Y2=Y2[,-5], 
              nB_d=nBd, nB_p=nBp,
              X_d1=Xd[[1]], X_d2=Xd[[2]], X_d3=Xd[[3]], 
              X_d4=Xd[[4]], X_p=Xp)
out <- stan(file="mod_sandbox/6-3_newCells_d0.stan", iter=2000, 
            data=d_SB1, thin=50, init=0, chains=4, seed=4337)
gg.nu <- ggs(out, "n_eta") %>% 
  # filter(!grepl("_new", .$Parameter)) %>%
  arrange(Parameter, Chain, Iteration)
nGG <- attr(gg.nu, "nChains")*attr(gg.nu, "nIterations")
gg.nu %<>% mutate(Y1=t(rbind(Y1.fit, Y1.new)) %>% c %>% rep(each=nGG),
                  Y2=t(cbind(Y2[,1:3], 
                             Y2[,4]*antilogit(Xp %*% Bp), 
                             Y2[,4]*(1-antilogit(Xp %*% Bp)), 
                             Y2[,5])) %>% c %>% rep(each=nGG),
                  LC=1:6 %>% rep(each=nGG) %>% rep(times=totCell),
                  Cell=1:totCell %>% rep(each=nGG*6),
                  Set=c("GRANIT & NLCD", "NLCD") %>% rep(times=c(nCell, nNew)*nGG*6)) %>%
  group_by(Cell, LC, Set, Parameter) %>%
  summarise(med=median(value), Y1=first(Y1), Y2=first(Y2)) %>%
  ungroup() %>% group_by(Cell)
# gg.new <- ggs(out, "n_eta_new") %>% arrange(Parameter, Chain, Iteration)
# nGG <- attr(gg.new, "nChains")*attr(gg.new, "nIterations")
# gg.new %<>% mutate(Y1.new=t(Y1.new) %>% c %>% rep(each=nGG),
#                   Y2.new=t(cbind(Y2.new[,1:3], 
#                                  Y2.new[,4]*antilogit(Xp.new %*% Bp),
#                                  Y2.new[,4]*(1-antilogit(Xp.new %*% Bp)), 
#                                  Y2.new[,5])) %>% c %>% rep(each=nGG),
#                   LC=1:6 %>% rep(each=nGG) %>% rep(times=nCell),
#                   Cell=1:nCell %>% rep(each=nGG*6)) %>%
#   group_by(Cell, LC, Parameter) %>%
#   summarise(med=median(value), Y1.new=first(Y1.new), Y2.new=first(Y2.new)) %>%
#   ungroup() %>% group_by(Cell)

ggplot(gg.nu, aes(x=Y1, y=med, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu, aes(x=Y1, y=Y2, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu, aes(x=Y2, y=med, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=Y2-Y1)) + geom_density(aes(x=med-Y1), colour="blue")
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=(med-Y1)^2-(Y2-Y1)^2, colour=Set))
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=(nuB-Y1)^2-(Y2-Y1)^2, colour=Set))
ggplot(gg.nu) + xlim(-1,1) + facet_wrap(~LC, scales="free_y") + 
  geom_vline(xintercept=0, linetype=3) +
  geom_density(aes(x=(med-Y1)^2-(Y2-Y1)^2, colour=Set))

ggplot(gg.nu, aes(x=med, y=nuB, colour=Set)) + geom_point(alpha=0.5) +
  geom_abline(slope=1, linetype=3) + facet_wrap(~LC) + xlim(0,1) + ylim(0,1)
ggplot(gg.nu, aes(x=Y1, xend=Y1, y=Y2, yend=med, colour=Set)) + xlim(0,1) + ylim(0,1) +
  geom_abline(slope=1, linetype=3) + scale_colour_brewer(type="qual", palette=2) +
  geom_segment(arrow=arrow(length=unit(0.1, "cm"))) + facet_wrap(~LC) +
  labs(x="Y1", y="Y2 -> median", main="no betas")
ggplot(gg.nu, aes(x=Y1, xend=Y1, y=Y2, yend=nuB, colour=Set)) + xlim(0,1) + ylim(0,1) +
  geom_abline(slope=1, linetype=3) + scale_colour_brewer(type="qual", palette=2) +
  geom_segment(arrow=arrow(length=unit(0.1, "cm"))) + facet_wrap(~LC) +
  labs(x="Y1", y="Y2 -> median", main="betas")
ggplot(gg.nu, aes(x=Y1, xend=Y1, y=med, yend=nuB, colour=abs(nuB-Y1)<abs(med-Y1))) + 
  xlim(0,1) + ylim(0,1) +
  geom_abline(slope=1, linetype=3) + scale_colour_manual(values=c("red", "darkgreen")) +
  geom_segment(arrow=arrow(length=unit(0.1, "cm"))) + facet_grid(Set~LC) +
  labs(x="Y1", y="no betas -> betas", main="model comparison") + theme(legend.position="none")
  
```

