---
title: "Veg Mod Exploration: JAGS"
author: "Tim Szewczyk"
date: "6/13/2017"
output: html_document
---

```{r setEnv, echo=FALSE, message=FALSE}
library(sevcheck); library(magrittr); library(tidyverse); theme_set(theme_bw())
library(forcats); library(rjags); library(ggmcmc); library(mvtnorm)

w_to_eta <- function(w, a=0.95) {
  eta <- w[-length(w)]
  eta[eta < 0] <- 0
  w.pred <- sum((eta<1)*eta + (eta>1))
  if(w.pred > a) {
    D.i <- (1 - (1-a)^(w.pred/a)) / w.pred
    eta <- D.i*eta
  }
  return(c(eta, 1-sum(eta)))
}

Z_Y_trans <- function(Z.v, g=2) {
  Z.v[Z.v<0] <- 0
  Z.l <- length(Z.v) - 1
  if(Z.v[Z.l]==0) { Z.v[Z.l] <- 0.01 }
  c((Z.v[1:Z.l]^g)/(1 + sum(Z.v[1:Z.l]^g)),
    1/(1 + sum(Z.v[1:Z.l]^g)))
}
```

# Read in data
```{r rdData}
# data from test grid (1-acre composition)
GRNT <- read.csv("data/t_y_mx.csv") %>% as.matrix
NLCD <- read.csv("data/t_x_mx.csv") %>% as.matrix
FIA <- runif(nrow(GRNT), 0, 1)

# Rearrange LC's
# t_mx order: [Dev, Evg, Hwd, Mxd, Other, WP]
GRNT <- GRNT[,c(1,5,3,4,2,6)]
NLCD <- NLCD[,c(1,5,3,4,2)]
```

# Model option 1
```{r mod1}
# simulate first
sd <- 0.1
b <- c(-10, 20)
p <- antilogit(b[1] + X.FIA*b[2])
w <- matrix(nrow=nCell, ncol=7)
y.sim <- w
for(cell in 1:nCell) {
  w[cell,] <- c(X[cell,1], X[cell,2], X[cell,3], X[cell,4], X[cell,5],
                p[cell]*X[cell,6], (1-p[cell])*X[cell,6])
  y.sim[cell,] <- rnorm(w[cell,], sd) %>% w_to_eta(a=0.85)
}

# build model
j_dat <- list(Y=y.sim, X=X, X.FIA=X.FIA, n=nCell)
pars <- c("w", "p", "b", "tau")
cat("model{
  # Likelihood
  for(cell in 1:n) {
    for(lc in 1:7) {
      Y[cell, lc] ~ dnorm(w[cell, lc], tau[lc])
    }
    w[cell,1:7] <- c(X[cell,1], X[cell,2], X[cell,3], X[cell,4], X[cell,5], 
                  p[cell]*X[cell,6], (1-p[cell])*X[cell,6])
    logit(p[cell]) <- b[1] + X.FIA[cell]*b[2]
  }
  
  # Priors
  for(i in 1:2) {
    b[i] ~ dnorm(0, 0.1)
  }
  for(i in 1:7) {
    tau[i] <- 1/(sd[i]*sd[i])
    sd[i] ~ dunif(0, 2)
  }
}", fill=TRUE, file="mod_sandbox/veg_SB1.txt")

mod <- jags.model("mod_sandbox/veg_SB1.txt", j_dat, n.chains=3, n.adapt=5000)
out <- coda.samples(mod, pars, n.iter=5000, thin=20)

gg.w <- ggs(out, "w")
nGG <- attr(gg.w, "nIterations")*attr(gg.w, "nChains")
gg.w$Cell <- rep(1:nCell, each=nGG*7)
gg.w$LC <- rep(1:7, each=nGG) %>% rep(nCell)
gg.w$w.true <- rep(c(t(w)), each=nGG)
ggplot(filter(gg.w, Iteration %in% seq(1,nGG,10)), aes(x=w.true, y=value)) +
  geom_point(alpha=0.05) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)

gg.p <- ggs(out, "p")
nGG <- attr(gg.p, "nIterations")*attr(gg.p, "nChains")
gg.p$Cell <- rep(1:nCell, each=nGG)
gg.p$p.true <- rep(p, each=nGG)
gg.p$f.prop <- (w[,6] + w[,7]) %>% rep(each=nGG)
ggplot(filter(gg.p, Iteration %in% seq(1,nGG,10)), aes(x=p.true, y=value)) +
  geom_point(aes(colour=f.prop), alpha=0.5) + geom_abline(slope=1, linetype=3)

gg.b <- ggs(out, "b")
ggs_traceplot(gg.b)
```

# Model option 2
```{r mod2.simple}
# Parameters & covariates
nCell <- 2000
nLC <- 6
err <- 0.01
samp.cells <- sample(1:nrow(GRNT), nCell)

# Storage objects
# mu <- rbeta(nCell*6, 0.4, 0.5) %>% matrix(nrow=nCell)
# mu <- rmvnorm(nCell, mean=rep(0.15, nLC), sigma=diag(0.05, nLC, nLC))
# mu <- mu %>% apply(., 1, w_to_eta, a=0.85) %>% t
mu <- GRNT[samp.cells,]
p.err <- rnorm(nCell, 0, 0.05)
p.wp <- (mu[,5] + p.err)
p.wp[p.wp < 0] <- 0
p.wp[p.wp > 1] <- 1
p <- p.wp/(p.wp+mu[,6]+0.0001)
Y1 <- matrix(nrow=nCell, ncol=nLC)
Y2 <- Y1[,-1]

for(i in 1:nCell) {
  # Y1: GRANIT
  Y1[i,] <- rmvnorm(1, mu[i,], diag(err, nLC, nLC)) 
  # Y2: NLCD
  Y2[i,] <- rmvnorm(1, c(mu[i,1:4], mu[i,5]+mu[i,6]), diag(err, nLC-1, nLC-1))
}
Y1 <- Y1 %>% apply(.,1,w_to_eta) %>% t
Y2 <- Y2 %>% apply(.,1,w_to_eta) %>% t


# simulated mu based on the means
Y1 <- GRNT[samp.cells,]
Y2 <- NLCD[samp.cells,]
p <- Y1[,5]/(Y1[,5] + Y1[,6] + 0.001) + rnorm(nCell, 0, 0.05)
p[p < 0] <- 0
p[p > 1] <- 1

mu <- matrix(nrow=nCell, ncol=nLC)
mu[,1:4] <- (Y1[,1:4] + Y2[,1:4])/2
mu[,5:6] <- (Y1[,5:6] + cbind(Y2[,5]*p, Y2[,5]*(1-p)))/2

plot(cbind(Y1[,1:4], rowSums(Y1[,5:6])), Y2)
plot(mu, Y1)
plot(cbind(mu[,1:4], rowSums(mu[,5:6])), Y2)
plot((mu[,5]/(mu[,5]+mu[,6])), p)

d_m2 <- list(Y1=Y1,
             Y2=Y2,
             p=p,
             n=nCell,
             nu.mu=rep(0.5, 6),
             nu.cov=diag(1, 6, 6))
cat("model{
  # Likelihood
  for(i in 1:n) {  # cells

    for(l in 1:4) {
      Y1[i,l] ~ dnorm(mu.a[i,l,1], tau[1])
      Y2[i,l] ~ dnorm(mu.a[i,l,2], tau[1])
    }
    Y1[i,5] ~ dnorm(mu.a[i,5,1], tau[1])
    Y1[i,6] ~ dnorm(mu.a[i,6,1], tau[1])
    Y2[i,5] ~ dnorm(mu.a[i,5,2] + mu.a[i,6,2], tau[2])

    for(l in 1:6) {
      for(j in 1:2) {
        mu.a[i,l,j] ~ dnorm(nu[i,l], tau[3])
      }
    }

    p[i] ~ dnorm(nu[i,5]/(nu[i,5]+nu[i,6]), tau[4])
  }


  # Priors
  for(i in 1:n) {
    nu[i,1:6] ~ dmnorm(nu.mu, nu.cov)
  }
  for(i in 1:4) {
    tau[i] <- 1/(sd[i]*sd[i])
    sd[i] ~ dunif(0,1)
  }
}", fill=TRUE, file="mod_sandbox/veg_SB2_simple.txt")

pars <- c("nu", "sd")
mod <- jags.model("mod_sandbox/veg_SB2_simple.txt", d_m2, n.chains=3, n.adapt=10000)
out <- coda.samples(mod, variable.names=pars, n.iter=5000)


gg.mu <- ggs(out, "nu")
nGG <- attr(gg.mu, "nIterations")*attr(gg.mu, "nChains")
gg.mu$Cell <- rep(1:nCell, each=nGG*6)
gg.mu$LC <- rep(1:6, each=nGG) %>% rep(nCell)
gg.mu$mu.true <- rep(c(t(mu)), each=nGG)
gg.mu$Y1 <- rep(c(t(Y1)), each=nGG)
gg.mu$Y2 <- rep(c(t(cbind(Y2, rep(NA, nrow(Y2))))), each=nGG)
gg.mu <- gg.mu %>% filter(Iteration %in% seq(1,nGG,200)) %>%
  group_by(Iteration, Chain, Cell) %>%
  mutate(value.eta=w_to_eta(value), value.scaled=value/sum(value),
         repInd=paste(Chain, Iteration, Cell, LC, sep="."))
ggplot(gg.mu, aes(x=mu.true, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.mu, aes(x=Y1, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.mu, aes(x=Y2, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)

gg.mu.a <- ggs(out, "mu.a")
gg.mu.a$Cell <- 1:nCell %>% rep(each=nGG*6*2)
gg.mu.a$LC <- 1:6 %>% rep(each=nGG*2) %>% rep(nCell)
gg.mu.a$Source <- c("GRNT", "NLCD") %>% rep(each=nGG) %>% rep(nCell*6)
gg.mu.a$mu.true <- t(mu) %>% c %>% rep(each=nGG*2)
gg.mu.a$repInd <- with(gg.mu.a, paste(Chain, Iteration, Cell, LC, sep="."))
gg.mu.a$nu <- gg.mu$value[match(gg.mu.a$repInd, gg.mu$repInd)]
gg.mu.a <- gg.mu.a %>% filter(Iteration %in% seq(1,nGG,200))
ggplot(gg.mu.a, aes(x=mu.true, y=value, colour=Source)) +
  geom_point(alpha=0.1) + geom_abline(slope=1, linetype=3) + facet_grid(Source~LC)
ggplot(gg.mu.a, aes(x=nu, y=value)) + geom_point(alpha=0.01) + 
  geom_abline(slope=1, linetype=3) + facet_grid(Source~LC)

gg.sd <- ggs(out, "sd")
ggs_caterpillar(gg.sd)

mu2 <- cbind(mu[,1:4], rowSums(mu[,5:6]))
Y1.rmse <- ((mu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((mu2 - Y2)^2) %>% colMeans %>% sqrt
gg.mu %>% group_by(LC) %>% mutate(sdev=(mu.true-value)^2) %>%
  summarise(mod.rmse=mean(sdev) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3),
         Y2.rmse=c(round(Y2.rmse,3), NA),
         diff.Y1=round(mod.rmse-Y1.rmse, 3), 
         propDiff.Y1=round(diff.Y1/Y1.rmse,3))
```

```{r mod2.d.sim}
nCell <- 20
nLC <- 6
nB.d <- 2
nB.p <- 2
X.d <- runif(nCell*nB.d, -1, 1) %>% matrix(nrow=nCell)
X.p <- runif(nCell*nB.p, -1, 1) %>% matrix(nrow=nCell)
B.d <- runif(nLC*nB.d, -0.5, 0.5) %>% matrix(nrow=nB.d)
B.p <- runif(nLC*nB.p, -1, 1) %>% matrix(nrow=nB.p)

nu <- GRNT[sample(1:nrow(GRNT), nCell),]

d <- X.d %*% B.d

Y1 <- nu; Y2 <- nu[,-1]; Z2 <- Y1
for(i in 1:nCell) {
  Y1[i,] <- rmvnorm(1, nu[i,], diag(0.01, nLC, nLC))
  Z2[i,] <- rmvnorm(1, nu[i,] + d[i,], diag(0.01, nLC, nLC))
}
Y2[,1:4] <- Z2[,1:4]
Y2[,5] <- Z2[,5] + Z2[,6]


# Y1 <- apply(Y1, 1, w_to_eta) %>% t
# Y2 <- apply(Y2, 1, w_to_eta) %>% t
plot(cbind(Y1[,1:4], rowSums(Y1[,5:6])), Y2)
p <- rnorm(nCell, mean(nu[,6]/(nu[,5]+nu[,6]+0.0001)), 0.05)
mnY <- Y1
mnY[,1:4] <- (Y1[,1:4] + Y2[,1:4])/2
mnY[,5:6] <- (Y1[,5:6] + cbind(Y2[,5]*(1-p), Y2[,5]*p))/2

d_sim <- list(Y1=Y1, Y2=Y2, X.d=X.d,
              p=p, n=nCell,
              cov.mx=diag(1, nLC, nLC),
              nu.mu=rep(0.5, 6))
cat("
data {
	for(i in 1:n) {
		Z2[i,1:4] <- Y2[i,1:4]
		Z2[i,5] <- Y2[i,5]*(1-p[i])
    Z2[i,6] <- Y2[i,5]*p[i]
		mu.a[i,1:6,1] <- Y1[i,1:6]
		mu.a[i,1:6,2] <- Z2[i,1:6]
	}
}

model {
  # Likelihood
	for(i in 1:n) {
		for(j in 1:2) {
      mu.a[i,1:6,j] ~ dmnorm(nu[i,1:6], mu.a.cov)
		}
		p[i] ~ dnorm(nu[i,6]/(nu[i,5]+nu[i,6]), tau)
	}

  # Priors
  for(i in 1:n) {
    nu[i,1:6] ~ ddirch(nu.mu)
  }
  mu.a.cov[1:6, 1:6] ~ dwish(cov.mx, 6)
  tau <- 1/(sd*sd)
  sd ~ dunif(0,1)
}", fill=TRUE, file="mod_sandbox/veg_SB2_d2.txt")

cat("
data {
	for(i in 1:n) {
		Z2[i,1:4] <- Y2[i,1:4]
		Z2[i,5] <- Y2[i,5]*(1-p[i])
    Z2[i,6] <- Y2[i,5]*p[i]
		mu.a[i,1:6,1] <- Y1[i,1:6]
		mu.a[i,1:6,2] <- Z2[i,1:6]
	}
}

model{
  # Likelihood
	for(i in 1:n) {
    mu.a[i,1:6,1] ~ dmnorm(nu[i,1:6], mu.a.cov)
    mu.a[i,1:6,2] ~ dmnorm(nu[i,1:6] + d[1:6], mu.a.cov)
		p[i] ~ dnorm(nu[i,6]/(nu[i,5]+nu[i,6]), tau)
	}

  # Priors
  for(i in 1:n) {
    nu[i,1:6] ~ ddirch(nu.mu)
  }
  for(l in 1:6) {
    d[l] ~ dnorm(0, 0.01)
  }
  mu.a.cov[1:6, 1:6] ~ dwish(cov.mx, 6)
  tau <- 1/(sd*sd)
  sd ~ dunif(0,1)
}", fill=TRUE, file="mod_sandbox/veg_SB2_d3.txt")

cat("
data {
	for(i in 1:n) {
		Z2[i,1:4] <- Y2[i,1:4]
		Z2[i,5] <- Y2[i,5]*(1-p[i])
    Z2[i,6] <- Y2[i,5]*(p[i])
		mu.a[i,1:6,1] <- Y1[i,1:6]
		mu.a[i,1:6,2] <- Z2[i,1:6]
	}
  nB.d <- dim(X.d)
}

model{
  # Likelihood
	for(i in 1:n) {
    mu.a[i,1:6,1] ~ dmnorm(nu[i,1:6], mu.a.cov)
    mu.a[i,1:6,2] ~ dmnorm(nu[i,1:6] + d[i,1:6], mu.a.cov)
    
    d[i,1:6] <- X.d[i,] %*% B.d
    
		p[i] ~ dnorm(nu[i,6]/(nu[i,5]+nu[i,6]), tau)
	}

  # Priors
  for(i in 1:n) {
    nu[i,1:6] ~ ddirch(nu.mu)
  }
  for(b in 1:nB.d[2]) {
    for(l in 1:6) {
      B.d[b,l] ~ dnorm(0, 0.01)
    }
  }
  mu.a.cov[1:6, 1:6] ~ dwish(cov.mx, 6)
  tau <- 1/(sd*sd)
  sd ~ dunif(0,1)
}", fill=TRUE, file="mod_sandbox/veg_SB2_d4.txt")

pars <- c("nu", "B.d", "sd")
mod <- jags.model("mod_sandbox/veg_SB2_d4.txt", d_sim, n.chains=3, n.adapt=5000)
out <- coda.samples(mod, variable.names=pars, n.iter=5000, n.thin=30)

gg.nu <- ggs(out, "nu")
nGG <- attr(gg.nu, "nIterations")*attr(gg.nu, "nChains")
gg.nu$Cell <- rep(1:nCell, each=nGG*6)
gg.nu$LC <- rep(1:6, each=nGG) %>% rep(nCell)
gg.nu$nu.true <- rep(c(t(nu)), each=nGG)
gg.nu$Y1 <- rep(c(t(Y1)), each=nGG)
gg.nu$Y2 <- rep(c(t(cbind(Y2, rep(NA, nrow(Y2))))), each=nGG)
gg.nu$mnY <- rep(c(t(mnY)), each=nGG)
gg.nu <- gg.nu %>% filter(Iteration %in% seq(1,nGG,200)) %>%
  group_by(Iteration, Chain, Cell) %>%
  mutate(value.eta=w_to_eta(value), value.scaled=value/sum(value),
         value.ZY=Z_Y_trans(value),
         repInd=paste(Chain, Iteration, Cell, LC, sep="."))
ggplot(gg.nu, aes(x=nu.true, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.eta)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.ZY)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=nu.true, y=value.scaled)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=mnY, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=Y1, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.nu, aes(x=Y2, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)

gg.Bd <- ggs(out, "B.d")
gg.Bd$LC <- rep(1:6, each=nGG) %>% rep(2)
gg.Bd$Bd.true <- rep(c(t(B.d)), each=nGG)
ggplot(gg.Bd, aes(x=Bd.true, y=value)) + geom_abline(slope=1, linetype=3) +
  geom_point(alpha=0.01)

nu2 <- cbind(nu[,1:4], rowSums(nu[,5:6]))
Y1.rmse <- ((nu - Y1)^2) %>% colMeans %>% sqrt
Y2.rmse <- ((nu2 - Y2)^2) %>% colMeans %>% sqrt
gg.nu %>% group_by(LC) %>% mutate(sdev=(nu.true-value)^2) %>%
  summarise(mod.rmse=mean(sdev) %>% sqrt %>% round(3)) %>%
  mutate(Y1.rmse=round(Y1.rmse,3),
         Y2.rmse=c(round(Y2.rmse,3), NA),
         diff.Y1=round(mod.rmse-Y1.rmse, 3), 
         propDiff.Y1=round(diff.Y1/Y1.rmse,3))

```


```{r mod2.d}
# Parameters & covariates
nCell <- 100
nLC <- 6
samp.cells <- sample(1:nrow(GRNT), nCell)

# simulated mu based on the means
Y1 <- GRNT[samp.cells,]
Y2 <- NLCD[samp.cells,]
p <- Y1[,5]/(Y1[,5] + Y1[,6] + 0.001) + rnorm(nCell, 0, 0.05)
p[p < 0] <- 0
p[p > 1] <- 1

mu <- matrix(nrow=nCell, ncol=nLC)
mu[,1:4] <- (Y1[,1:4] + Y2[,1:4])/2
mu[,5:6] <- (Y1[,5:6] + cbind(Y2[,5]*p, Y2[,5]*(1-p)))/2

plot(cbind(Y1[,1:4], rowSums(Y1[,5:6])), Y2)
par(mfrow=c(2,3))
apply(cbind(Y1[,1:4], rowSums(Y1[,5:6])) - Y2, 2, hist, xlim=c(-1,1), breaks=20)
par(mfrow=c(1,1))
plot(mu, Y1)
plot(cbind(mu[,1:4], rowSums(mu[,5:6])), Y2)
plot((mu[,5]/(mu[,5]+mu[,6])), p)

d_m2 <- list(Y1=Y1,
             Y2=Y2,
             p=p,
             n=nCell,
             cov.mx=diag(1, nLC, nLC),
             nu.mu=rep(0.5, 6))
cat("model{
  # Likelihood
  for(i in 1:n) {  # cells

    for(l in 1:4) {
      Y1[i,l] ~ dnorm(mu.a[i,l,1] + d[l,1], tau[1])
      Y2[i,l] ~ dnorm(mu.a[i,l,2] + d[l,2], tau[1])
    }
    Y1[i,5] ~ dnorm(mu.a[i,5,1] + d[5,1], tau[1])
    Y1[i,6] ~ dnorm(mu.a[i,6,1] + d[6,1], tau[1])
    Y2[i,5] ~ dnorm(mu.a[i,5,2] + mu.a[i,6,2] + d[5,2], tau[2])

    for(j in 1:2) {
      mu.a[i,1:6,j] ~ dmnorm(nu[i,1:6], mu.a.cov[1:6, 1:6])
    }

    p[i] ~ dnorm(nu[i,5]/(nu[i,5]+nu[i,6]), tau[3])
  }


  # Priors
  for(i in 1:n) {
    nu[i,1:6] ~ ddirch(nu.mu)
  }
  for(l in 1:5) {
    for(j in 1:2) {
      d[l,j] ~ dnorm(0, 0.01)
    }
  }
  d[6,1] ~ dnorm(0, 0.01)
  mu.a.cov[1:6, 1:6] ~ dwish(cov.mx, 6)
  for(i in 1:3) {
    tau[i] <- 1/(sd[i]*sd[i])
    sd[i] ~ dunif(0,1)
  }
}", fill=TRUE, file="mod_sandbox/veg_SB2_d.txt")

pars <- c("nu", "d")
mod <- jags.model("mod_sandbox/veg_SB2_d.txt", d_m2, n.chains=3, n.adapt=2000)
out <- coda.samples(mod, variable.names=pars, n.iter=5000)


gg.mu <- ggs(out, "nu")
nGG <- attr(gg.mu, "nIterations")*attr(gg.mu, "nChains")
gg.mu$Cell <- rep(1:nCell, each=nGG*6)
gg.mu$LC <- rep(1:6, each=nGG) %>% rep(nCell)
gg.mu$mu.true <- rep(c(t(mu)), each=nGG)
gg.mu$Y1 <- rep(c(t(Y1)), each=nGG)
gg.mu$Y2 <- rep(c(t(cbind(Y2, rep(NA, nrow(Y2))))), each=nGG)
gg.mu <- gg.mu %>% filter(Iteration %in% seq(1,nGG,200)) %>%
  group_by(Iteration, Chain, Cell) %>%
  mutate(value.eta=w_to_eta(value), value.scaled=value/sum(value),
         value.ZY=Z_Y_trans(value),
         repInd=paste(Chain, Iteration, Cell, LC, sep="."))
ggplot(gg.mu, aes(x=mu.true, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.mu, aes(x=Y1, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)
ggplot(gg.mu, aes(x=Y2, y=value)) +
  geom_point(alpha=0.02) + geom_abline(slope=1, linetype=3) + facet_wrap(~LC)


gg.d <- ggs(out, "d")
ggs_caterpillar(gg.d)
ggs_traceplot(gg.d) + facet_wrap(~Parameter)

gg.cov <- ggs(out, "mu.a.cov")
ggs_caterpillar(gg.cov)
ggs_traceplot(gg.cov) + facet_wrap(~Parameter)
```



```{r mod2.b.nu}
# Here, we assume that the covariates drive the latent land cover proportions. The variation of GRANIT and NLCD about the latent land cover is still considered random and unaccounted for.
```

```{r mod2.b.mu.a}
# Here, we assume that the covariates drive the deviation of NLCD and GRANIT from the latent land cover proportions. This structure requires that there is some systematic d in the estimate of each dataset compared to the latent proportions.
```





